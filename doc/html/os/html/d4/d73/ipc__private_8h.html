<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OS: ipc_private.h File Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('d4/d73/ipc__private_8h.html','../../');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">ipc_private.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="../../d9/d24/ipc_8h_source.html">ipc/ipc.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../dc/d63/hydra_8h_source.html">hydra/hydra.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../d5/dd9/hydra__types_8h_source.html">hydra/hydra_types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../d5/d08/buffer_8h_source.html">buffer/buffer.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../df/d1f/panic_8h_source.html">panic/panic.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../da/d67/hydra__log_8h_source.html">hydra_log/hydra_log.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../dc/da7/assert_8h_source.html">assert.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../d7/d00/sched_8h_source.html">sched/sched.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../d3/d7e/int_8h_source.html">int/int.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../d8/ddb/pmalloc_8h_source.html">pmalloc/pmalloc.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../db/d47/hal__macros_8h_source.html">hal/hal_macros.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../d6/dac/dorm_8h_source.html">dorm/dorm.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../d7/db1/utils__bits__and__bobs_8h_source.html">utils/utils_bits_and_bobs.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../dd/db4/fault_8h_source.html">fault/fault.h</a>&quot;</code><br />
<code>#include &quot;memory_map.h&quot;</code><br />
<code>#include &quot;<a class="el" href="../../d7/d65/trap__api_8h_source.html">trap_api/trap_api.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../de/d19/trap__version_8h_source.html">trap_version/trap_version.h</a>&quot;</code><br />
</div>
<p><a href="../../d4/d73/ipc__private_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d7e/structIPC__RECV__CB__QUEUE.html">IPC_RECV_CB_QUEUE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for implementing the queue of receive callbacks.  <a href="../../df/d7e/structIPC__RECV__CB__QUEUE.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/df3/structIPC__MSG__QUEUE.html">IPC_MSG_QUEUE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for implementing the queue of pending messages, i.e.  <a href="../../da/df3/structIPC__MSG__QUEUE.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d8a/structIPC__DATA.html">IPC_DATA</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Top-level storage for IPC internal data.  <a href="../../d8/d8a/structIPC__DATA.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d72/structPANIC__DATA.html">PANIC_DATA</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct used to store panic data.  <a href="../../d2/d72/structPANIC__DATA.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a40ea11b0a6c88ab19120b74d150bdb53"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d73/ipc__private_8h.html#a40ea11b0a6c88ab19120b74d150bdb53">IO_DEFS_MODULE_KALIMBA_INTERPROC_INT</a></td></tr>
<tr class="separator:a40ea11b0a6c88ab19120b74d150bdb53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5180558855daeadc16a3aa4fe20be8f0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d73/ipc__private_8h.html#a5180558855daeadc16a3aa4fe20be8f0">IPC_BUFFER_SIZE</a>&#160;&#160;&#160;MMU_BUFFER_SIZE_512</td></tr>
<tr class="memdesc:a5180558855daeadc16a3aa4fe20be8f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the IPC send and receive buffers.  <a href="#a5180558855daeadc16a3aa4fe20be8f0">More...</a><br /></td></tr>
<tr class="separator:a5180558855daeadc16a3aa4fe20be8f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a701c85eac86aafcc2ab1cc32f3cec320"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d73/ipc__private_8h.html#a701c85eac86aafcc2ab1cc32f3cec320">IPC_MAX_RECV_MSGS</a>&#160;&#160;&#160;10</td></tr>
<tr class="memdesc:a701c85eac86aafcc2ab1cc32f3cec320"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of messages to process in one invocation of the receive handler.  <a href="#a701c85eac86aafcc2ab1cc32f3cec320">More...</a><br /></td></tr>
<tr class="separator:a701c85eac86aafcc2ab1cc32f3cec320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e80e6274e2b1fe6680ca333d2fe2c42"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d73/ipc__private_8h.html#a8e80e6274e2b1fe6680ca333d2fe2c42">hal_set_reg_interproc_event_1</a>&#160;&#160;&#160;hal_set_reg_p1_to_p0_interproc_event_1</td></tr>
<tr class="separator:a8e80e6274e2b1fe6680ca333d2fe2c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0890481e0474ce60d5dd1731272ac0a4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d73/ipc__private_8h.html#a0890481e0474ce60d5dd1731272ac0a4">hal_set_reg_interproc_event_2</a>&#160;&#160;&#160;hal_set_reg_p1_to_p0_interproc_event_2</td></tr>
<tr class="separator:a0890481e0474ce60d5dd1731272ac0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ec3ed9ebae9a14fc69ea01a3bc997c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d73/ipc__private_8h.html#a33ec3ed9ebae9a14fc69ea01a3bc997c">IPC_SEND_POINTER</a>(ptr)</td></tr>
<tr class="memdesc:a33ec3ed9ebae9a14fc69ea01a3bc997c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to encapsulate the code for sending a raw pointer in the IPC buffer, rather than a proper IPC message.  <a href="#a33ec3ed9ebae9a14fc69ea01a3bc997c">More...</a><br /></td></tr>
<tr class="separator:a33ec3ed9ebae9a14fc69ea01a3bc997c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06bdcdd83a19a2b7391ae350f8f914ca"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d73/ipc__private_8h.html#a06bdcdd83a19a2b7391ae350f8f914ca">IPC_RECV_POINTER</a>(ptr,  type)</td></tr>
<tr class="memdesc:a06bdcdd83a19a2b7391ae350f8f914ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to encapsulate the code for synchronously receiving a raw pointer in the IPC buffer, rather than via a proper IPC message.  <a href="#a06bdcdd83a19a2b7391ae350f8f914ca">More...</a><br /></td></tr>
<tr class="separator:a06bdcdd83a19a2b7391ae350f8f914ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7835589248490f7e096ef3dcb9b96f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d73/ipc__private_8h.html#abc7835589248490f7e096ef3dcb9b96f">IPC_SEND_VALUE</a>(value)</td></tr>
<tr class="memdesc:abc7835589248490f7e096ef3dcb9b96f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to encapsulate the code for sending a raw uint32 in the IPC buffer, rather than a proper IPC message.  <a href="#abc7835589248490f7e096ef3dcb9b96f">More...</a><br /></td></tr>
<tr class="separator:abc7835589248490f7e096ef3dcb9b96f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b81e7b01b7604c4bb2dcfbae2e3a01e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d73/ipc__private_8h.html#a1b81e7b01b7604c4bb2dcfbae2e3a01e">IPC_RECV_VALUE</a>(value)</td></tr>
<tr class="memdesc:a1b81e7b01b7604c4bb2dcfbae2e3a01e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to encapsulate the code for synchronously receiving a raw uint32 in the IPC buffer, rather than via a proper IPC message.  <a href="#a1b81e7b01b7604c4bb2dcfbae2e3a01e">More...</a><br /></td></tr>
<tr class="separator:a1b81e7b01b7604c4bb2dcfbae2e3a01e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a6b8480dbfe2f62014cab7897a2ab3716"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="../../df/d7e/structIPC__RECV__CB__QUEUE.html">IPC_RECV_CB_QUEUE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d73/ipc__private_8h.html#a6b8480dbfe2f62014cab7897a2ab3716">IPC_RECV_CB_QUEUE</a></td></tr>
<tr class="memdesc:a6b8480dbfe2f62014cab7897a2ab3716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for implementing the queue of receive callbacks.  <a href="#a6b8480dbfe2f62014cab7897a2ab3716">More...</a><br /></td></tr>
<tr class="separator:a6b8480dbfe2f62014cab7897a2ab3716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed98495daab79076cb783ceb68390cc4"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="../../da/df3/structIPC__MSG__QUEUE.html">IPC_MSG_QUEUE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d73/ipc__private_8h.html#aed98495daab79076cb783ceb68390cc4">IPC_MSG_QUEUE</a></td></tr>
<tr class="memdesc:aed98495daab79076cb783ceb68390cc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for implementing the queue of pending messages, i.e.  <a href="#aed98495daab79076cb783ceb68390cc4">More...</a><br /></td></tr>
<tr class="separator:aed98495daab79076cb783ceb68390cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae1ad11682fa5665dc62a2db70f51816d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d73/ipc__private_8h.html#ae1ad11682fa5665dc62a2db70f51816d">ipc_clear_queue</a> (void)</td></tr>
<tr class="memdesc:ae1ad11682fa5665dc62a2db70f51816d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post as many messages from the "back-up" queue as possible.  <a href="#ae1ad11682fa5665dc62a2db70f51816d">More...</a><br /></td></tr>
<tr class="separator:ae1ad11682fa5665dc62a2db70f51816d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee3e57effdf307fad7d506203e594373"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d73/ipc__private_8h.html#aee3e57effdf307fad7d506203e594373">ipc_queue_msg_core</a> (<a class="el" href="../../da/df3/structIPC__MSG__QUEUE.html">IPC_MSG_QUEUE</a> **pqueue, <a class="el" href="../../d6/d88/ipc__prim_8h.html#a06fa3898c777e365dda72551f0720b93">IPC_SIGNAL_ID</a> msg_id, const void *msg, uint16 len_bytes)</td></tr>
<tr class="memdesc:aee3e57effdf307fad7d506203e594373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to place a message on a given <a class="el" href="../../da/df3/structIPC__MSG__QUEUE.html" title="Type for implementing the queue of pending messages, i.e. ">IPC_MSG_QUEUE</a>.  <a href="#aee3e57effdf307fad7d506203e594373">More...</a><br /></td></tr>
<tr class="separator:aee3e57effdf307fad7d506203e594373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a091d1fffb837acfba25d30d6005b0518"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d73/ipc__private_8h.html#a091d1fffb837acfba25d30d6005b0518">ipc_recv_handler</a> (void *blocking_msg)</td></tr>
<tr class="memdesc:a091d1fffb837acfba25d30d6005b0518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process everything in the receive buffer.  <a href="#a091d1fffb837acfba25d30d6005b0518">More...</a><br /></td></tr>
<tr class="separator:a091d1fffb837acfba25d30d6005b0518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a797293f26ce27064d343c2601ba30f86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d73/ipc__private_8h.html#a797293f26ce27064d343c2601ba30f86">ipc_mmu_msg_handler</a> (<a class="el" href="../../d6/d88/ipc__prim_8h.html#a06fa3898c777e365dda72551f0720b93">IPC_SIGNAL_ID</a> id, const void *msg)</td></tr>
<tr class="memdesc:a797293f26ce27064d343c2601ba30f86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handler for MMU and buffer related IPC signals.  <a href="#a797293f26ce27064d343c2601ba30f86">More...</a><br /></td></tr>
<tr class="separator:a797293f26ce27064d343c2601ba30f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac942dfb10f9b794d774b672c92288ed5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d73/ipc__private_8h.html#ac942dfb10f9b794d774b672c92288ed5">ipc_malloc_msg_handler</a> (<a class="el" href="../../d6/d88/ipc__prim_8h.html#a06fa3898c777e365dda72551f0720b93">IPC_SIGNAL_ID</a> id, const void *msg)</td></tr>
<tr class="memdesc:ac942dfb10f9b794d774b672c92288ed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handler for pmalloc and smalloc related IPC signals.  <a href="#ac942dfb10f9b794d774b672c92288ed5">More...</a><br /></td></tr>
<tr class="separator:ac942dfb10f9b794d774b672c92288ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e84c6debbcd92915932f406a8e559b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d73/ipc__private_8h.html#ab7e84c6debbcd92915932f406a8e559b">ipc_fault_panic_msg_handler</a> (<a class="el" href="../../d6/d88/ipc__prim_8h.html#a06fa3898c777e365dda72551f0720b93">IPC_SIGNAL_ID</a> id, const <a class="el" href="../../d9/d91/structIPC__FAULT__PANIC.html">IPC_FAULT_PANIC</a> *msg)</td></tr>
<tr class="memdesc:ab7e84c6debbcd92915932f406a8e559b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handler for fault/panic related IPC signals.  <a href="#ab7e84c6debbcd92915932f406a8e559b">More...</a><br /></td></tr>
<tr class="separator:ab7e84c6debbcd92915932f406a8e559b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbfc2ef14f398eac3f0a092a7045c5e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d73/ipc__private_8h.html#abbfc2ef14f398eac3f0a092a7045c5e7">ipc_test_tunnel_handler</a> (<a class="el" href="../../d6/d88/ipc__prim_8h.html#a06fa3898c777e365dda72551f0720b93">IPC_SIGNAL_ID</a> id, const void *msg, uint16 msg_length_bytes)</td></tr>
<tr class="memdesc:abbfc2ef14f398eac3f0a092a7045c5e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handler for test tunnel primitives.  <a href="#abbfc2ef14f398eac3f0a092a7045c5e7">More...</a><br /></td></tr>
<tr class="separator:abbfc2ef14f398eac3f0a092a7045c5e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a642fec3ef2b53bdad9f2274aba3a2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d73/ipc__private_8h.html#a0a642fec3ef2b53bdad9f2274aba3a2e">ipc_deep_sleep_msg_handler</a> (<a class="el" href="../../d6/d88/ipc__prim_8h.html#a06fa3898c777e365dda72551f0720b93">IPC_SIGNAL_ID</a> id, const void *msg)</td></tr>
<tr class="memdesc:a0a642fec3ef2b53bdad9f2274aba3a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handler for seep sleep related IPC signals.  <a href="#a0a642fec3ef2b53bdad9f2274aba3a2e">More...</a><br /></td></tr>
<tr class="separator:a0a642fec3ef2b53bdad9f2274aba3a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717eb5f92fd63d4115e973657d983244"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d73/ipc__private_8h.html#a717eb5f92fd63d4115e973657d983244">ipc_bluestack_handler</a> (<a class="el" href="../../d6/d88/ipc__prim_8h.html#a06fa3898c777e365dda72551f0720b93">IPC_SIGNAL_ID</a> id, const void *msg)</td></tr>
<tr class="memdesc:a717eb5f92fd63d4115e973657d983244"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handler for Bluestack primitives.  <a href="#a717eb5f92fd63d4115e973657d983244">More...</a><br /></td></tr>
<tr class="separator:a717eb5f92fd63d4115e973657d983244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5309b47bfd7e169edbefd0c091183ab3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d73/ipc__private_8h.html#a5309b47bfd7e169edbefd0c091183ab3">ipc_sched_handler</a> (<a class="el" href="../../d6/d88/ipc__prim_8h.html#a06fa3898c777e365dda72551f0720b93">IPC_SIGNAL_ID</a> id, const void *msg)</td></tr>
<tr class="memdesc:a5309b47bfd7e169edbefd0c091183ab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handler for scheduler message primitives.  <a href="#a5309b47bfd7e169edbefd0c091183ab3">More...</a><br /></td></tr>
<tr class="separator:a5309b47bfd7e169edbefd0c091183ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad52e51646c436c314b6abebbc46e37"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d73/ipc__private_8h.html#a8ad52e51646c436c314b6abebbc46e37">ipc_trap_api_handler</a> (<a class="el" href="../../d6/d88/ipc__prim_8h.html#a06fa3898c777e365dda72551f0720b93">IPC_SIGNAL_ID</a> id, const void *msg, uint16 msg_len)</td></tr>
<tr class="memdesc:a8ad52e51646c436c314b6abebbc46e37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handler for app standard messages.  <a href="#a8ad52e51646c436c314b6abebbc46e37">More...</a><br /></td></tr>
<tr class="separator:a8ad52e51646c436c314b6abebbc46e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7467c85a5bb6a02aae160f4c95fcddf3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d73/ipc__private_8h.html#a7467c85a5bb6a02aae160f4c95fcddf3">ipc_trap_api_fast_handler</a> (<a class="el" href="../../d6/d88/ipc__prim_8h.html#a06fa3898c777e365dda72551f0720b93">IPC_SIGNAL_ID</a> id, const void *msg)</td></tr>
<tr class="memdesc:a7467c85a5bb6a02aae160f4c95fcddf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handler for app 'fast' messages.  <a href="#a7467c85a5bb6a02aae160f4c95fcddf3">More...</a><br /></td></tr>
<tr class="separator:a7467c85a5bb6a02aae160f4c95fcddf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0660d999bb42469e4a79d1d3953a7927"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d73/ipc__private_8h.html#a0660d999bb42469e4a79d1d3953a7927">ipc_stream_handler</a> (<a class="el" href="../../d6/d88/ipc__prim_8h.html#a06fa3898c777e365dda72551f0720b93">IPC_SIGNAL_ID</a> id, const void *msg)</td></tr>
<tr class="memdesc:a0660d999bb42469e4a79d1d3953a7927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handler for stream related messages from P0 to P1.  <a href="#a0660d999bb42469e4a79d1d3953a7927">More...</a><br /></td></tr>
<tr class="separator:a0660d999bb42469e4a79d1d3953a7927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8ac529a27d65c75dd20414d563afad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d73/ipc__private_8h.html#a3c8ac529a27d65c75dd20414d563afad">ipc_test_init</a> (void)</td></tr>
<tr class="memdesc:a3c8ac529a27d65c75dd20414d563afad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise the IPC Appcmd-based tests.  <a href="#a3c8ac529a27d65c75dd20414d563afad">More...</a><br /></td></tr>
<tr class="separator:a3c8ac529a27d65c75dd20414d563afad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17b10b626676ea156aad517ae4bc920"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d73/ipc__private_8h.html#ab17b10b626676ea156aad517ae4bc920">ipc_test_high_priority_handler</a> (Task t, MessageId id, Message m)</td></tr>
<tr class="memdesc:ab17b10b626676ea156aad517ae4bc920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test handler function for hi_pri_stream_handler_test.  <a href="#ab17b10b626676ea156aad517ae4bc920">More...</a><br /></td></tr>
<tr class="separator:ab17b10b626676ea156aad517ae4bc920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90043c8fc800caa712e40f7af1e8195"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d73/ipc__private_8h.html#af90043c8fc800caa712e40f7af1e8195">panic_interrupt_handler</a> (void)</td></tr>
<tr class="memdesc:af90043c8fc800caa712e40f7af1e8195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Panic interrupt handler.  <a href="#af90043c8fc800caa712e40f7af1e8195">More...</a><br /></td></tr>
<tr class="separator:af90043c8fc800caa712e40f7af1e8195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0b907fac9e20b26df8144b46c04f88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d73/ipc__private_8h.html#a1d0b907fac9e20b26df8144b46c04f88">ipc_send_trap_api_version_info</a> (void)</td></tr>
<tr class="memdesc:a1d0b907fac9e20b26df8144b46c04f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send an IPC message passing the trap API version information.  <a href="#a1d0b907fac9e20b26df8144b46c04f88">More...</a><br /></td></tr>
<tr class="separator:a1d0b907fac9e20b26df8144b46c04f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a235916f744e5ad4dce9919b5b6132a74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d73/ipc__private_8h.html#a235916f744e5ad4dce9919b5b6132a74">ipc_trap_api_version_prim_handler</a> (<a class="el" href="../../d6/d88/ipc__prim_8h.html#a06fa3898c777e365dda72551f0720b93">IPC_SIGNAL_ID</a> id, const void *prim)</td></tr>
<tr class="memdesc:a235916f744e5ad4dce9919b5b6132a74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handler for the trap API version information message.  <a href="#a235916f744e5ad4dce9919b5b6132a74">More...</a><br /></td></tr>
<tr class="separator:a235916f744e5ad4dce9919b5b6132a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfdfd780297b2ce87717c12d4e64c184"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d73/ipc__private_8h.html#adfdfd780297b2ce87717c12d4e64c184">ipc_leave_recv_buffer_pages_mapped</a> (void)</td></tr>
<tr class="memdesc:adfdfd780297b2ce87717c12d4e64c184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Leave IPC receive buffer pages mapped instead of freeing them.  <a href="#adfdfd780297b2ce87717c12d4e64c184">More...</a><br /></td></tr>
<tr class="separator:adfdfd780297b2ce87717c12d4e64c184"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a80e614285e6a54852828a9394571aa17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/d8a/structIPC__DATA.html">IPC_DATA</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d73/ipc__private_8h.html#a80e614285e6a54852828a9394571aa17">ipc_data</a></td></tr>
<tr class="memdesc:a80e614285e6a54852828a9394571aa17"><td class="mdescLeft">&#160;</td><td class="mdescRight">IPC implementation data instance.  <a href="#a80e614285e6a54852828a9394571aa17">More...</a><br /></td></tr>
<tr class="separator:a80e614285e6a54852828a9394571aa17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b479c31751d4b03341896e368312217"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d2/d72/structPANIC__DATA.html">PANIC_DATA</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d73/ipc__private_8h.html#a8b479c31751d4b03341896e368312217">panic_data</a></td></tr>
<tr class="memdesc:a8b479c31751d4b03341896e368312217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Panic data instance.  <a href="#a8b479c31751d4b03341896e368312217">More...</a><br /></td></tr>
<tr class="separator:a8b479c31751d4b03341896e368312217"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a8e80e6274e2b1fe6680ca333d2fe2c42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e80e6274e2b1fe6680ca333d2fe2c42">&#9670;&nbsp;</a></span>hal_set_reg_interproc_event_1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define hal_set_reg_interproc_event_1&#160;&#160;&#160;hal_set_reg_p1_to_p0_interproc_event_1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0890481e0474ce60d5dd1731272ac0a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0890481e0474ce60d5dd1731272ac0a4">&#9670;&nbsp;</a></span>hal_set_reg_interproc_event_2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define hal_set_reg_interproc_event_2&#160;&#160;&#160;hal_set_reg_p1_to_p0_interproc_event_2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a40ea11b0a6c88ab19120b74d150bdb53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ea11b0a6c88ab19120b74d150bdb53">&#9670;&nbsp;</a></span>IO_DEFS_MODULE_KALIMBA_INTERPROC_INT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IO_DEFS_MODULE_KALIMBA_INTERPROC_INT</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5180558855daeadc16a3aa4fe20be8f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5180558855daeadc16a3aa4fe20be8f0">&#9670;&nbsp;</a></span>IPC_BUFFER_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IPC_BUFFER_SIZE&#160;&#160;&#160;MMU_BUFFER_SIZE_512</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The size of the IPC send and receive buffers. </p>
<p>The implementation is tolerant of overflowing the IPC buffers: it puts messages it canâ€™t insert into a linked list until it can insert them. Hence we trade off buffer size against pmalloc memory. Not only buffer-size is important, since a buffer can be logically full (contains 16 messages) before it is physically full. Enhancing the BUFFER_MSG class to fall back on pmalloc for additional logical slots, increases implementation complexity, and we have chosen not to. </p>

</div>
</div>
<a id="a701c85eac86aafcc2ab1cc32f3cec320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a701c85eac86aafcc2ab1cc32f3cec320">&#9670;&nbsp;</a></span>IPC_MAX_RECV_MSGS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IPC_MAX_RECV_MSGS&#160;&#160;&#160;10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of messages to process in one invocation of the receive handler. </p>

</div>
</div>
<a id="a06bdcdd83a19a2b7391ae350f8f914ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06bdcdd83a19a2b7391ae350f8f914ca">&#9670;&nbsp;</a></span>IPC_RECV_POINTER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IPC_RECV_POINTER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {\</div><div class="line">        const uint8 *from_px = <a class="code" href="../../dd/db4/buffer__msg_8h.html#a11f5b6be125210d05379342d9129308f">buf_map_back_msg</a>(<a class="code" href="../../d4/d73/ipc__private_8h.html#a80e614285e6a54852828a9394571aa17">ipc_data</a>.<a class="code" href="../../d8/d8a/structIPC__DATA.html#ac477876a866ab74c2b9695f389030a2c">recv</a>); \</div><div class="line">        assert(<a class="code" href="../../dd/db4/buffer__msg_8h.html#a0fad1ff3b2206ce378bd8f0df5d68d7b">buf_get_back_msg_len</a>(<a class="code" href="../../d4/d73/ipc__private_8h.html#a80e614285e6a54852828a9394571aa17">ipc_data</a>.<a class="code" href="../../d8/d8a/structIPC__DATA.html#ac477876a866ab74c2b9695f389030a2c">recv</a>) == <span class="keyword">sizeof</span>(uint32)); \</div><div class="line">        (ptr) = (type *)(*((<span class="keyword">const</span> uint32 *)from_px)); \</div><div class="line">        buf_update_back(<a class="code" href="../../d4/d73/ipc__private_8h.html#a80e614285e6a54852828a9394571aa17">ipc_data</a>.<a class="code" href="../../d8/d8a/structIPC__DATA.html#ac477876a866ab74c2b9695f389030a2c">recv</a>); \</div><div class="line">        buf_update_behind_free(<a class="code" href="../../d4/d73/ipc__private_8h.html#a80e614285e6a54852828a9394571aa17">ipc_data</a>.<a class="code" href="../../d8/d8a/structIPC__DATA.html#ac477876a866ab74c2b9695f389030a2c">recv</a>); \</div><div class="line">    } <span class="keywordflow">while</span> (0)</div><div class="ttc" id="ipc__private_8h_html_a80e614285e6a54852828a9394571aa17"><div class="ttname"><a href="../../d4/d73/ipc__private_8h.html#a80e614285e6a54852828a9394571aa17">ipc_data</a></div><div class="ttdeci">IPC_DATA ipc_data</div><div class="ttdoc">IPC implementation data instance. </div><div class="ttdef"><b>Definition:</b> ipc_init.c:6</div></div>
<div class="ttc" id="structIPC__DATA_html_ac477876a866ab74c2b9695f389030a2c"><div class="ttname"><a href="../../d8/d8a/structIPC__DATA.html#ac477876a866ab74c2b9695f389030a2c">IPC_DATA::recv</a></div><div class="ttdeci">BUFFER_MSG * recv</div><div class="ttdoc">The receive message buffer. </div><div class="ttdef"><b>Definition:</b> ipc_private.h:88</div></div>
<div class="ttc" id="buffer__msg_8h_html_a11f5b6be125210d05379342d9129308f"><div class="ttname"><a href="../../dd/db4/buffer__msg_8h.html#a11f5b6be125210d05379342d9129308f">buf_map_back_msg</a></div><div class="ttdeci">#define buf_map_back_msg(msg_buf)</div><div class="ttdoc">Map in the buffer for reading the current message (at back) The downstream protocol modules use this ...</div><div class="ttdef"><b>Definition:</b> buffer_msg.h:313</div></div>
<div class="ttc" id="buffer__msg_8h_html_a0fad1ff3b2206ce378bd8f0df5d68d7b"><div class="ttname"><a href="../../dd/db4/buffer__msg_8h.html#a0fad1ff3b2206ce378bd8f0df5d68d7b">buf_get_back_msg_len</a></div><div class="ttdeci">#define buf_get_back_msg_len(buf)</div><div class="ttdoc">Get the length of the message at the back of a message ring. </div><div class="ttdef"><b>Definition:</b> buffer_msg.h:306</div></div>
</div><!-- fragment -->
<p>Macro to encapsulate the code for synchronously receiving a raw pointer in the IPC buffer, rather than via a proper IPC message. </p>
<p>Used at initialisation time. </p>

</div>
</div>
<a id="a1b81e7b01b7604c4bb2dcfbae2e3a01e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b81e7b01b7604c4bb2dcfbae2e3a01e">&#9670;&nbsp;</a></span>IPC_RECV_VALUE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IPC_RECV_VALUE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">value</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {\</div><div class="line">        const uint8 *from_px = <a class="code" href="../../dd/db4/buffer__msg_8h.html#a11f5b6be125210d05379342d9129308f">buf_map_back_msg</a>(<a class="code" href="../../d4/d73/ipc__private_8h.html#a80e614285e6a54852828a9394571aa17">ipc_data</a>.<a class="code" href="../../d8/d8a/structIPC__DATA.html#ac477876a866ab74c2b9695f389030a2c">recv</a>); \</div><div class="line">        assert(<a class="code" href="../../dd/db4/buffer__msg_8h.html#a0fad1ff3b2206ce378bd8f0df5d68d7b">buf_get_back_msg_len</a>(<a class="code" href="../../d4/d73/ipc__private_8h.html#a80e614285e6a54852828a9394571aa17">ipc_data</a>.<a class="code" href="../../d8/d8a/structIPC__DATA.html#ac477876a866ab74c2b9695f389030a2c">recv</a>) == <span class="keyword">sizeof</span>(uint32)); \</div><div class="line">        (value) = *((<span class="keyword">const</span> uint32 *)from_px); \</div><div class="line">        buf_update_back(<a class="code" href="../../d4/d73/ipc__private_8h.html#a80e614285e6a54852828a9394571aa17">ipc_data</a>.<a class="code" href="../../d8/d8a/structIPC__DATA.html#ac477876a866ab74c2b9695f389030a2c">recv</a>); \</div><div class="line">        buf_update_behind_free(<a class="code" href="../../d4/d73/ipc__private_8h.html#a80e614285e6a54852828a9394571aa17">ipc_data</a>.<a class="code" href="../../d8/d8a/structIPC__DATA.html#ac477876a866ab74c2b9695f389030a2c">recv</a>); \</div><div class="line">    } <span class="keywordflow">while</span> (0)</div><div class="ttc" id="ipc__private_8h_html_a80e614285e6a54852828a9394571aa17"><div class="ttname"><a href="../../d4/d73/ipc__private_8h.html#a80e614285e6a54852828a9394571aa17">ipc_data</a></div><div class="ttdeci">IPC_DATA ipc_data</div><div class="ttdoc">IPC implementation data instance. </div><div class="ttdef"><b>Definition:</b> ipc_init.c:6</div></div>
<div class="ttc" id="structIPC__DATA_html_ac477876a866ab74c2b9695f389030a2c"><div class="ttname"><a href="../../d8/d8a/structIPC__DATA.html#ac477876a866ab74c2b9695f389030a2c">IPC_DATA::recv</a></div><div class="ttdeci">BUFFER_MSG * recv</div><div class="ttdoc">The receive message buffer. </div><div class="ttdef"><b>Definition:</b> ipc_private.h:88</div></div>
<div class="ttc" id="buffer__msg_8h_html_a11f5b6be125210d05379342d9129308f"><div class="ttname"><a href="../../dd/db4/buffer__msg_8h.html#a11f5b6be125210d05379342d9129308f">buf_map_back_msg</a></div><div class="ttdeci">#define buf_map_back_msg(msg_buf)</div><div class="ttdoc">Map in the buffer for reading the current message (at back) The downstream protocol modules use this ...</div><div class="ttdef"><b>Definition:</b> buffer_msg.h:313</div></div>
<div class="ttc" id="buffer__msg_8h_html_a0fad1ff3b2206ce378bd8f0df5d68d7b"><div class="ttname"><a href="../../dd/db4/buffer__msg_8h.html#a0fad1ff3b2206ce378bd8f0df5d68d7b">buf_get_back_msg_len</a></div><div class="ttdeci">#define buf_get_back_msg_len(buf)</div><div class="ttdoc">Get the length of the message at the back of a message ring. </div><div class="ttdef"><b>Definition:</b> buffer_msg.h:306</div></div>
</div><!-- fragment -->
<p>Macro to encapsulate the code for synchronously receiving a raw uint32 in the IPC buffer, rather than via a proper IPC message. </p>
<p>Used at initialisation time. </p>

</div>
</div>
<a id="a33ec3ed9ebae9a14fc69ea01a3bc997c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33ec3ed9ebae9a14fc69ea01a3bc997c">&#9670;&nbsp;</a></span>IPC_SEND_POINTER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IPC_SEND_POINTER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {\</div><div class="line">        uint8 *to_px = <a class="code" href="../../dd/db4/buffer__msg_8h.html#a65bfb543d76bc38849d860436b9e4a18">buf_map_front_msg</a>(<a class="code" href="../../d4/d73/ipc__private_8h.html#a80e614285e6a54852828a9394571aa17">ipc_data</a>.<a class="code" href="../../d8/d8a/structIPC__DATA.html#a4e92fcebc1f19aa3eb44bfc3bfdd5704">send</a>);\</div><div class="line">        assert(<span class="keyword">sizeof</span>(uint32) == <span class="keyword">sizeof</span>(<span class="keywordtype">void</span> *));\</div><div class="line">        *((uint32 *)to_px) = (uint32)(ptr);\</div><div class="line">        buf_add_to_front(<a class="code" href="../../d4/d73/ipc__private_8h.html#a80e614285e6a54852828a9394571aa17">ipc_data</a>.<a class="code" href="../../d8/d8a/structIPC__DATA.html#a4e92fcebc1f19aa3eb44bfc3bfdd5704">send</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">void</span> *));\</div><div class="line">    } <span class="keywordflow">while</span> (0)</div><div class="ttc" id="ipc__private_8h_html_a80e614285e6a54852828a9394571aa17"><div class="ttname"><a href="../../d4/d73/ipc__private_8h.html#a80e614285e6a54852828a9394571aa17">ipc_data</a></div><div class="ttdeci">IPC_DATA ipc_data</div><div class="ttdoc">IPC implementation data instance. </div><div class="ttdef"><b>Definition:</b> ipc_init.c:6</div></div>
<div class="ttc" id="structIPC__DATA_html_a4e92fcebc1f19aa3eb44bfc3bfdd5704"><div class="ttname"><a href="../../d8/d8a/structIPC__DATA.html#a4e92fcebc1f19aa3eb44bfc3bfdd5704">IPC_DATA::send</a></div><div class="ttdeci">BUFFER_MSG * send</div><div class="ttdoc">The send message buffer. </div><div class="ttdef"><b>Definition:</b> ipc_private.h:87</div></div>
<div class="ttc" id="buffer__msg_8h_html_a65bfb543d76bc38849d860436b9e4a18"><div class="ttname"><a href="../../dd/db4/buffer__msg_8h.html#a65bfb543d76bc38849d860436b9e4a18">buf_map_front_msg</a></div><div class="ttdeci">#define buf_map_front_msg(msg_buf)</div><div class="ttdoc">Map in the buffer for writing the current message (at front) This should be followed by a call to buf...</div><div class="ttdef"><b>Definition:</b> buffer_msg.h:298</div></div>
</div><!-- fragment -->
<p>Macro to encapsulate the code for sending a raw pointer in the IPC buffer, rather than a proper IPC message. </p>
<p>Used at initialisation time. </p>

</div>
</div>
<a id="abc7835589248490f7e096ef3dcb9b96f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc7835589248490f7e096ef3dcb9b96f">&#9670;&nbsp;</a></span>IPC_SEND_VALUE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IPC_SEND_VALUE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">value</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {\</div><div class="line">        uint8 *to_px = <a class="code" href="../../dd/db4/buffer__msg_8h.html#a65bfb543d76bc38849d860436b9e4a18">buf_map_front_msg</a>(<a class="code" href="../../d4/d73/ipc__private_8h.html#a80e614285e6a54852828a9394571aa17">ipc_data</a>.<a class="code" href="../../d8/d8a/structIPC__DATA.html#a4e92fcebc1f19aa3eb44bfc3bfdd5704">send</a>);\</div><div class="line">        *((uint32 *)to_px) = (value);\</div><div class="line">        buf_add_to_front(<a class="code" href="../../d4/d73/ipc__private_8h.html#a80e614285e6a54852828a9394571aa17">ipc_data</a>.<a class="code" href="../../d8/d8a/structIPC__DATA.html#a4e92fcebc1f19aa3eb44bfc3bfdd5704">send</a>, <span class="keyword">sizeof</span>(uint32));\</div><div class="line">    } <span class="keywordflow">while</span> (0)</div><div class="ttc" id="ipc__private_8h_html_a80e614285e6a54852828a9394571aa17"><div class="ttname"><a href="../../d4/d73/ipc__private_8h.html#a80e614285e6a54852828a9394571aa17">ipc_data</a></div><div class="ttdeci">IPC_DATA ipc_data</div><div class="ttdoc">IPC implementation data instance. </div><div class="ttdef"><b>Definition:</b> ipc_init.c:6</div></div>
<div class="ttc" id="structIPC__DATA_html_a4e92fcebc1f19aa3eb44bfc3bfdd5704"><div class="ttname"><a href="../../d8/d8a/structIPC__DATA.html#a4e92fcebc1f19aa3eb44bfc3bfdd5704">IPC_DATA::send</a></div><div class="ttdeci">BUFFER_MSG * send</div><div class="ttdoc">The send message buffer. </div><div class="ttdef"><b>Definition:</b> ipc_private.h:87</div></div>
<div class="ttc" id="buffer__msg_8h_html_a65bfb543d76bc38849d860436b9e4a18"><div class="ttname"><a href="../../dd/db4/buffer__msg_8h.html#a65bfb543d76bc38849d860436b9e4a18">buf_map_front_msg</a></div><div class="ttdeci">#define buf_map_front_msg(msg_buf)</div><div class="ttdoc">Map in the buffer for writing the current message (at front) This should be followed by a call to buf...</div><div class="ttdef"><b>Definition:</b> buffer_msg.h:298</div></div>
</div><!-- fragment -->
<p>Macro to encapsulate the code for sending a raw uint32 in the IPC buffer, rather than a proper IPC message. </p>
<p>Used at initialisation time. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="aed98495daab79076cb783ceb68390cc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed98495daab79076cb783ceb68390cc4">&#9670;&nbsp;</a></span>IPC_MSG_QUEUE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="../../da/df3/structIPC__MSG__QUEUE.html">IPC_MSG_QUEUE</a>  <a class="el" href="../../da/df3/structIPC__MSG__QUEUE.html">IPC_MSG_QUEUE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for implementing the queue of pending messages, i.e. </p>
<p>those that have been posted for sending but haven't made it into the buffer yet due to a lack of space </p>

</div>
</div>
<a id="a6b8480dbfe2f62014cab7897a2ab3716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b8480dbfe2f62014cab7897a2ab3716">&#9670;&nbsp;</a></span>IPC_RECV_CB_QUEUE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="../../df/d7e/structIPC__RECV__CB__QUEUE.html">IPC_RECV_CB_QUEUE</a>  <a class="el" href="../../df/d7e/structIPC__RECV__CB__QUEUE.html">IPC_RECV_CB_QUEUE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for implementing the queue of receive callbacks. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a717eb5f92fd63d4115e973657d983244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a717eb5f92fd63d4115e973657d983244">&#9670;&nbsp;</a></span>ipc_bluestack_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ipc_bluestack_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/d88/ipc__prim_8h.html#a06fa3898c777e365dda72551f0720b93">IPC_SIGNAL_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handler for Bluestack primitives. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Signal ID (= <code>IPC_SIGNAL_ID_BLUESTACK_PRIM</code>) </td></tr>
    <tr><td class="paramname">msg</td><td>Message body </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1ad11682fa5665dc62a2db70f51816d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1ad11682fa5665dc62a2db70f51816d">&#9670;&nbsp;</a></span>ipc_clear_queue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc_clear_queue </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Post as many messages from the "back-up" queue as possible. </p>
<dl class="section note"><dt>Note</dt><dd>This function must be called with interrupts blocked!</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the queue is now empty, else FALSE </dd></dl>

</div>
</div>
<a id="a0a642fec3ef2b53bdad9f2274aba3a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a642fec3ef2b53bdad9f2274aba3a2e">&#9670;&nbsp;</a></span>ipc_deep_sleep_msg_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ipc_deep_sleep_msg_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/d88/ipc__prim_8h.html#a06fa3898c777e365dda72551f0720b93">IPC_SIGNAL_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handler for seep sleep related IPC signals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Signal ID </td></tr>
    <tr><td class="paramname">msg</td><td>Message body, including header </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7e84c6debbcd92915932f406a8e559b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7e84c6debbcd92915932f406a8e559b">&#9670;&nbsp;</a></span>ipc_fault_panic_msg_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ipc_fault_panic_msg_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/d88/ipc__prim_8h.html#a06fa3898c777e365dda72551f0720b93">IPC_SIGNAL_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d91/structIPC__FAULT__PANIC.html">IPC_FAULT_PANIC</a> *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handler for fault/panic related IPC signals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Signal ID </td></tr>
    <tr><td class="paramname">msg</td><td>Message body, including header </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adfdfd780297b2ce87717c12d4e64c184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfdfd780297b2ce87717c12d4e64c184">&#9670;&nbsp;</a></span>ipc_leave_recv_buffer_pages_mapped()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ipc_leave_recv_buffer_pages_mapped </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Leave IPC receive buffer pages mapped instead of freeing them. </p>
<p>Once a page has finished being used the IPC receive buffer can either free the page or leave it to be reused later on. Freeing the page saves on RAM at the expense of making it more difficult to debug the IPC module.</p>
<p>If the IpcLeaveRecvBufferPagesMapped MIB key is set this function should be called to leave the IPC receive buffer pages mapped in, otherwise they will be freed. </p>

</div>
</div>
<a id="ac942dfb10f9b794d774b672c92288ed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac942dfb10f9b794d774b672c92288ed5">&#9670;&nbsp;</a></span>ipc_malloc_msg_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ipc_malloc_msg_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/d88/ipc__prim_8h.html#a06fa3898c777e365dda72551f0720b93">IPC_SIGNAL_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handler for pmalloc and smalloc related IPC signals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Signal ID </td></tr>
    <tr><td class="paramname">msg</td><td>Message body, including header </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a797293f26ce27064d343c2601ba30f86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a797293f26ce27064d343c2601ba30f86">&#9670;&nbsp;</a></span>ipc_mmu_msg_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ipc_mmu_msg_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/d88/ipc__prim_8h.html#a06fa3898c777e365dda72551f0720b93">IPC_SIGNAL_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handler for MMU and buffer related IPC signals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Signal ID </td></tr>
    <tr><td class="paramname">msg</td><td>Message body, including header </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee3e57effdf307fad7d506203e594373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee3e57effdf307fad7d506203e594373">&#9670;&nbsp;</a></span>ipc_queue_msg_core()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ipc_queue_msg_core </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/df3/structIPC__MSG__QUEUE.html">IPC_MSG_QUEUE</a> **&#160;</td>
          <td class="paramname"><em>pqueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/d88/ipc__prim_8h.html#a06fa3898c777e365dda72551f0720b93">IPC_SIGNAL_ID</a>&#160;</td>
          <td class="paramname"><em>msg_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>len_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to place a message on a given <a class="el" href="../../da/df3/structIPC__MSG__QUEUE.html" title="Type for implementing the queue of pending messages, i.e. ">IPC_MSG_QUEUE</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pqueue</td><td>Pointer to the queue to place the message on </td></tr>
    <tr><td class="paramname">msg_id</td><td>The IPC signal </td></tr>
    <tr><td class="paramname">msg</td><td>The message body </td></tr>
    <tr><td class="paramname">len_bytes</td><td>The message length in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a091d1fffb837acfba25d30d6005b0518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a091d1fffb837acfba25d30d6005b0518">&#9670;&nbsp;</a></span>ipc_recv_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ipc_recv_handler </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>blocking_msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process everything in the receive buffer. </p>
<p>If the current blocking_msg_id is encountered amongst them, save a copy of the payload in a local pmalloc block and return it to the caller after everything has been processed. Ownership of the memory is passed to the caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blocking_msg</td><td>Pointer to pre-allocated space for any expected message, or NULL if the message should be pmalloc'd internally. If this function isn't being called in the context of blocking, the value is irrelevant, except that it will be returned unchanged, so it is highly recommended to pass NULL, so that the case where an blocking message is erroneously received can be detected (e.g. see <code><a class="el" href="../../df/df4/ipc__sched_8c.html#a8c70f0b5e8a53fdbb7c6a47ee59aeeb6">ipc_background_handler()</a></code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the blocking message body, if any: equal to <code>blocking_msg</code> if this is not NULL, else points to an internally pmalloc'd copy of the message if there was one, else NULL </dd></dl>

</div>
</div>
<a id="a5309b47bfd7e169edbefd0c091183ab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5309b47bfd7e169edbefd0c091183ab3">&#9670;&nbsp;</a></span>ipc_sched_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ipc_sched_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/d88/ipc__prim_8h.html#a06fa3898c777e365dda72551f0720b93">IPC_SIGNAL_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handler for scheduler message primitives. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Signal ID (= <code>IPC_SIGNAL_ID_SCHED_MSG_PRIM</code>) </td></tr>
    <tr><td class="paramname">msg</td><td>Message body </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d0b907fac9e20b26df8144b46c04f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d0b907fac9e20b26df8144b46c04f88">&#9670;&nbsp;</a></span>ipc_send_trap_api_version_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ipc_send_trap_api_version_info </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send an IPC message passing the trap API version information. </p>

</div>
</div>
<a id="a0660d999bb42469e4a79d1d3953a7927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0660d999bb42469e4a79d1d3953a7927">&#9670;&nbsp;</a></span>ipc_stream_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ipc_stream_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/d88/ipc__prim_8h.html#a06fa3898c777e365dda72551f0720b93">IPC_SIGNAL_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handler for stream related messages from P0 to P1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Signal ID </td></tr>
    <tr><td class="paramname">msg</td><td>Message body </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab17b10b626676ea156aad517ae4bc920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab17b10b626676ea156aad517ae4bc920">&#9670;&nbsp;</a></span>ipc_test_high_priority_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ipc_test_high_priority_handler </td>
          <td>(</td>
          <td class="paramtype">Task&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MessageId&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Message&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test handler function for hi_pri_stream_handler_test. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Task message posted to </td></tr>
    <tr><td class="paramname">id</td><td>Message ID </td></tr>
    <tr><td class="paramname">m</td><td>Message body </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c8ac529a27d65c75dd20414d563afad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c8ac529a27d65c75dd20414d563afad">&#9670;&nbsp;</a></span>ipc_test_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ipc_test_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise the IPC Appcmd-based tests. </p>

</div>
</div>
<a id="abbfc2ef14f398eac3f0a092a7045c5e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbfc2ef14f398eac3f0a092a7045c5e7">&#9670;&nbsp;</a></span>ipc_test_tunnel_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ipc_test_tunnel_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/d88/ipc__prim_8h.html#a06fa3898c777e365dda72551f0720b93">IPC_SIGNAL_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>msg_length_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handler for test tunnel primitives. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Signal ID (= <code>IPC_SIGNAL_ID_TEST_TUNNEL_PRIM</code>) </td></tr>
    <tr><td class="paramname">msg</td><td>Message body, including header </td></tr>
    <tr><td class="paramname">msg_length_bytes</td><td>Total length of the message in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7467c85a5bb6a02aae160f4c95fcddf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7467c85a5bb6a02aae160f4c95fcddf3">&#9670;&nbsp;</a></span>ipc_trap_api_fast_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc_trap_api_fast_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/d88/ipc__prim_8h.html#a06fa3898c777e365dda72551f0720b93">IPC_SIGNAL_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handler for app 'fast' messages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Signal ID </td></tr>
    <tr><td class="paramname">msg</td><td>Message body </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FALSE if message handler is high-priority but the IPC is currently blocking on an atomic response; otherwise TRUE </dd></dl>

</div>
</div>
<a id="a8ad52e51646c436c314b6abebbc46e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ad52e51646c436c314b6abebbc46e37">&#9670;&nbsp;</a></span>ipc_trap_api_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc_trap_api_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/d88/ipc__prim_8h.html#a06fa3898c777e365dda72551f0720b93">IPC_SIGNAL_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>msg_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handler for app standard messages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Signal ID </td></tr>
    <tr><td class="paramname">msg</td><td>Message body </td></tr>
    <tr><td class="paramname">msg_len</td><td>Length of <code>msg</code> in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FALSE if message handler is high-priority but the IPC is currently blocking on an atomic response; otherwise TRUE </dd></dl>

</div>
</div>
<a id="a235916f744e5ad4dce9919b5b6132a74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a235916f744e5ad4dce9919b5b6132a74">&#9670;&nbsp;</a></span>ipc_trap_api_version_prim_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ipc_trap_api_version_prim_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/d88/ipc__prim_8h.html#a06fa3898c777e365dda72551f0720b93">IPC_SIGNAL_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>prim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handler for the trap API version information message. </p>
<p>Handler for the trap API version information message.</p>
<p>CS-328404-DD-LATEST.pdf, section 7.2.1 describes the compatibility criteria: That major versions must match and the minor version of P1 code must be less than or equal to the minor version of P0 code. </p>

</div>
</div>
<a id="af90043c8fc800caa712e40f7af1e8195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af90043c8fc800caa712e40f7af1e8195">&#9670;&nbsp;</a></span>panic_interrupt_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void panic_interrupt_handler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Panic interrupt handler. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a80e614285e6a54852828a9394571aa17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80e614285e6a54852828a9394571aa17">&#9670;&nbsp;</a></span>ipc_data</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/d8a/structIPC__DATA.html">IPC_DATA</a> ipc_data</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IPC implementation data instance. </p>

</div>
</div>
<a id="a8b479c31751d4b03341896e368312217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b479c31751d4b03341896e368312217">&#9670;&nbsp;</a></span>panic_data</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d2/d72/structPANIC__DATA.html">PANIC_DATA</a>* panic_data</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Panic data instance. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../dir_9104b11b055a08855e18ab07d1360a34.html">apps_ext_adk64r_RC_CI_qcc512x_qcc302x_1908091004</a></li><li class="navelem"><a class="el" href="../../dir_19c4644e84b768df42bf93899dbb4e83.html">apps_package</a></li><li class="navelem"><a class="el" href="../../dir_e9f51238b5eab91050ba7b42263dc658.html">progfiles</a></li><li class="navelem"><a class="el" href="../../dir_86fefe393b7ca9a63838560cf4ca04cf.html">apps</a></li><li class="navelem"><a class="el" href="../../dir_240681f6dc407f95ae9103d80499b5b4.html">fw</a></li><li class="navelem"><a class="el" href="../../dir_67a3fc20251395f7d62aa73621d4d7c9.html">src</a></li><li class="navelem"><a class="el" href="../../dir_721b2a6acf65b21a05ec9c4de6b97c06.html">core</a></li><li class="navelem"><a class="el" href="../../dir_7ea9e1f68719b86e36e3df60a7d8f0f6.html">ipc</a></li><li class="navelem"><a class="el" href="../../d4/d73/ipc__private_8h.html">ipc_private.h</a></li>
    <li class="footer">Copyright (c) 2019 Qualcomm Technologies International, Ltd. Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
